2.1 Σχεδιάζεται η παραλληλοποίηση του τμήματος κώδικα που αναλαμβάνει τον υπολογισμό των δεδομένων που αφορούν αποκλειστικά σε αυτό το τμήμα. Η εκτέλεση του συγκεκριμένου τμήματος δεν εξαρτάται από οποιοδήποτε άλλο τμήμα του προγράμματος.

2.2
//create thread and run
for (int index; index<NumTh; index++) {
	create thread(index, data[index])
	run thread
}

//waiting to finish
for (int index; index<NumTh; index++) {
	wait thread(index, data[index])
}

//get result
for (int index; index<NumTh; index++){
	data[index] = thread(index).data
}

2.3 
Αν ο χρόνος ακολουθιακής εκτέλεσης είναι T, τότε ο χρόνος παράλληλης εκτέλεσης είναι T/N, όπου Ν είναι ο αριθμός των νημάτων.Παρόλα αυτά, αυτή η εκτίμηση ισχύει μόνο υπό ιδανικές συνθήκες παραλληλισμού. Στην πραγματικότητα, η βελτίωση μπορεί να είναι μικρότερη λόγω παραγόντων όπως η επικοινωνία μεταξύ νημάτων και η διαχείριση του παράλληλου περιβάλλοντος.

2.4
RGBtoGrayScale(πριν 620ms, μετά 380ms)
SetPixels(πριν 640ms, μετά 340ms)
SimpleSat(πριν 5200ms, μετά 1300ms)

Στα πρώτα δύο προγράμματα (RGBtoGrayScale, SetPixels), παρατηρούμε ότι ο κώδικας εκτελείται 1.6-1.8 φορές γρηγορότερα από ό,τι το τελευταίο πρόγραμμα (SimpleSat), το οποίο εκτελείται περίπου 4 φορές πιο γρήγορα.
